<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Performance of SPA built on React.js</h2>
					<aside class="notes">
						Сегодня мы рассмотрим аспекты которые необходимо учитывать при разработке SPA-приложений на React.js для достижения оптимальной
						производительности. В этом докладе мы рассмотрим в основном о React.js версии 15 и ранее. 
						Будет упомянут и React 16, известный под кодовым именем Fiber, но вкратце, так как эта библиотека
						довольно недавно вышла в production и поработать с ним еще не довелось.
					</aside>
				</section>
				<section>
					<h3>React is fast, React is slow</h3>
					<section>
						<h4>Expectations</h4>
						<img height="200" data-src="./assets/road_runner.jpg" alt="Road Runner">
					</section>
					<section>
						<h4>Reality</h4>
						<img width="400" data-src="./assets/coyote.jpg" alt="Coyote">
					</section>
					<aside class="notes">
						Устоявшимся стереотипом о React.js является то, что он дает быструю отрисовку “из коробки”. Поэтому, чаще всего
						мы ожидаем от приложений написанных на React вот такой быстроты. Слепо взяв это на веру мы начинаем писать приложение как душе угодно, и
						в результате все оказывается не так радужно. Наши ожидания не оправдываются, приложение тормозит,
						память переполняется, отрисовка происходит долго. Кто виноват: React или то, как мы написали свое приложение?
					</aside>
				</section>
				<section>
					<h3>How React does make render?</h3>
					<img data-src="./assets/react-render-to-dom.gif" alt="Steps of render process">
					<aside class="notes">
						Начнем рассмотрение с того, как работает React.js.
						Известно, что строительным элементом в React является компонент, который имеет свой жизненный цикл: создание, изначальная отрисовка,
						обновление и последующая отрисовка, и отсоединение, когда компонент больше не нужен в DOM.
						Отрисовка каждого из компонентов происходит в так называемом дереве Virtual DOM, состояние которого является
						“отражением” реального DOM документа. Это состояние хранится в памяти, пока работает ваше приложение.
						Обновления вызывают перерисовки и между отрисовками происходит сравнение состояний дерева Virtual DOM, и вычисленная разница
						затем уже применяется к DOM реальному, изменяя только то, что необходимо. Этот алгоритм называется Reconciliation.
						Надо заметить, что операция сверки рекурсивно проходит по всему виртуальному древу и это 
						происходит <strong>синхронно</strong>, то есть является блокирующей операцией для основного потока.
					</aside>
				</section>
				<section>
					<blockquote cite="https://twitter.com/dan_abramov/status/790333373864669185">
						&ldquo;Oh, and no, React is not faster than DOM. Sorry. But it lets you build large performant apps without thinking too much about
						performance.&rdquo;
						<p>Dan Abramov</p>
					</blockquote>
					<aside class="notes">
						И есть замечательная цитата Дэна Абрамова насчет скорости Virtual DOM по сравнению с реальным.
					</aside>					
				</section>
				<section>
					<h3>How to measure performance?</h3>
					<ul>
						<li class="fragment">Chrome Dev Tools</li>
						<li class="fragment">React Dev Tools</li>
						<li class="fragment"><code>react-addons-perf</code> + <code>?react_perf</code></li>
						<li class="fragment">Performance API</li>
					</ul>
					<aside class="notes">
						Итак, как можно измерить производительность нашего приложения? Какие утилиты для этого существуют?
						1. Конечно, Chrome Dev Tools, куда ж без них. Здесь могли бы быть и другие Dev tool'ы других браузеров, но 
						набор инструментов в Хроме намного больше и удобнее чем в Firefox, про IE вообще промолчим. 
						2. Также в джентельменский набор React разработчика входит и React Dev Tools, которые можно установить как расширение 
						в Chrome, Opera, FF. Для Safari и IE нужно будет установить react-devtools как npm-пакет глобально и запускать
						из терминала как отдельное приложение
						3. React Addons - это набор различных полезных утилит среди которых есть Test Utils и Perf. Нас интересует именно Perf.
						Этот пакет поддерживался вплоть до React 16. В React 16 встроено отображение процессов отрисовки и многого другого прямо
						в Chrome Dev Tools при записи Performance Timeline.
						Для React 15 есть флаг react_perf который можно добавить как query параметр	к строке адреса dev сервера и посмотреть тайминги
						отрисовок и обновлений при записи Performance Timeline.
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						### React Addons Perf  

						```
						npm i -d react-addons-perf
						```
						
						How to use?
						```js
						import Perf from 'react-addons-perf'

						// on will mount
						Perf.start()
						// on did mount
						Perf.stop()

						const msr = Perf.getLastMeasurements()
						Perf.printInclusive(msr)
						Perf.printWasted(msr)
						```
					</script>
				</section>
				<section>
					<h3>Components Timing With Chrome Dev Tools</h3>
					<code>http://localhost:3000?react_perf</code>
					<img src="./assets/components-timing.png" alt="Components Timing"/>
				</section>
				<section data-markdown>
					<script type="text/template">
						### Performance API  

						```js
						// Start with one mark.
						performance.mark("start-mark");

						// Wait some time.
						setTimeout(function() {
							// Mark the end of the time.
							performance.mark("end-mark");

							// Measure between the two different markers.
							performance.measure(
								"perf-measurement",
								"start-mark",
								"end-mark"
							);

							// Get all of the measures out.
							// In this case there is only one.
							var measures = performance.getEntriesByName("perf-measurement");
							var measure = measures[0];
							console.log("setTimeout milliseconds:", measure.duration)

							// Clean up the stored markers.
							performance.clearMarks();
							performance.clearMeasures();
						}, 1000);
						```
					</script>
				</section>
				<section>
					<h3>Weak Points and Ways To Optimization</h3>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
